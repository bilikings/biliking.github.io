<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Groza&#39;s</title>
  <icon>http://bilikings.top/icon.png</icon>
  <subtitle>噫|呜|呜|噫</subtitle>
  <link href="http://bilikings.top/atom.xml" rel="self"/>
  
  <link href="http://bilikings.top/"/>
  <updated>2020-11-22T12:21:45.616Z</updated>
  <id>http://bilikings.top/</id>
  
  <author>
    <name>Biliking</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程笔记(6)——线程池</title>
    <link href="http://bilikings.top/2020/11/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-7-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://bilikings.top/2020/11/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-7-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-11-22T12:19:12.000Z</published>
    <updated>2020-11-22T12:21:45.616Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;线程池的使用&quot;&gt;&lt;a href=&quot;#线程池的使用&quot; class=&quot;headerlink&quot; title=&quot;线程池的使用&quot;&gt;&lt;/a&gt;线程池的使用&lt;/h2&gt;&lt;p&gt;有些任务需要明确的指定执行策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖性任务：如果线程池中的任务需要依赖其他任务的活动，那么就隐含的给执行策略带来了约束&lt;/li&gt;
&lt;li&gt;使用线程封闭机制的任务：单线程的Executor可以对并发性做出更强的承诺，对象封闭在任务线程中，使得线程中的任务访问这个对象时不会同步，&lt;/li&gt;
&lt;li&gt;对响应时间敏感的任务：把每个运行时间长的任务交给单线程的Executor中，会降低Executor管理服务的响应性&lt;/li&gt;
&lt;li&gt;使用ThreadLocal的任务：ThreadLocal可以让每个线程都拥有一个变量的私有复制。只有当线程本地值的什么周期受限于任务的生命周期时，在线程池中使用ThreadLocal才有意义，而且在线程池中的线程不应该使用ThreadLocal在任务之间传递值&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程笔记(6)——任务</title>
    <link href="http://bilikings.top/2020/11/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-6-%E2%80%94%E2%80%94%E4%BB%BB%E5%8A%A1/"/>
    <id>http://bilikings.top/2020/11/22/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-6-%E2%80%94%E2%80%94%E4%BB%BB%E5%8A%A1/</id>
    <published>2020-11-22T12:18:58.000Z</published>
    <updated>2020-11-22T12:20:58.831Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;任务执行&quot;&gt;&lt;a href=&quot;#任务执行&quot; class=&quot;headerlink&quot; title=&quot;任务执行&quot;&gt;&lt;/a&gt;任务执行&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;任务&lt;/strong&gt;通常是一项抽象并且离散的一些单元。&lt;/p&gt;
&lt;p&gt;可以把应用程序分解到多个任务中，可以简化程序的组织结构，提供一种自然的事务边界来优化错误的恢复过程&lt;/p&gt;
&lt;h3 id=&quot;在线程中执行任务&quot;&gt;&lt;a href=&quot;#在线程中执行任务&quot; class=&quot;headerlink&quot; title=&quot;在线程中执行任务&quot;&gt;&lt;/a&gt;在线程中执行任务&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;找出任务边界&lt;/li&gt;
&lt;li&gt;任务并不依赖其他的任务的状态、结果、边界效应。&lt;/li&gt;
&lt;li&gt;多数web服务器的任务边界是一独立的客户请求为边界&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RedisMQ</title>
    <link href="http://bilikings.top/2020/11/19/RedisMQ/"/>
    <id>http://bilikings.top/2020/11/19/RedisMQ/</id>
    <published>2020-11-19T01:29:53.000Z</published>
    <updated>2020-11-19T01:30:31.129Z</updated>
    
    
    <summary type="html">&lt;p&gt;Redis实现轻量级的消息队列与消息中间件相比，没有高级特性也没有ACK保证，无法做到数据不重不漏，如果业务简单而且对消息的可靠性不是那么严格可以尝试使用。&lt;/p&gt;
&lt;p&gt;Redis中列表&lt;code&gt;List&lt;/code&gt;类型是按照插入顺序排序的字符串链表，和数据结构中的普通链表一样，可以在头部&lt;code&gt;left&lt;/code&gt;和尾部&lt;code&gt;right&lt;/code&gt;添加新的元素。插入时如果键不存在Redis将为该键创建一个新的链表。如果链表中所有元素均被删除，那么该键也会被删除。&lt;/p&gt;
&lt;p&gt;Redis提供了两种方式来做消息队列，一种是&lt;strong&gt;生产消费模式&lt;/strong&gt;，另一种是&lt;strong&gt;发布订阅模式&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Redis" scheme="http://bilikings.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程笔记(4)——同步工具类</title>
    <link href="http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-4-%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-4-%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-11-17T09:07:27.000Z</published>
    <updated>2020-11-17T09:10:42.452Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;同步工具类&quot;&gt;&lt;a href=&quot;#同步工具类&quot; class=&quot;headerlink&quot; title=&quot;同步工具类&quot;&gt;&lt;/a&gt;同步工具类&lt;/h2&gt;&lt;p&gt;同步工具类可以是任何一个对象，只要他根据自身的状态了协调线程的控制流。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞队列&lt;/li&gt;
&lt;li&gt;信号量（Semaphore）&lt;/li&gt;
&lt;li&gt;栅栏（Barrier）&lt;/li&gt;
&lt;li&gt;闭锁（Latch）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;也可以通过一些机制来创建自己的同步工具类&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程笔记(5)——同步的基础构建模块</title>
    <link href="http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-5-%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97/"/>
    <id>http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-5-%E2%80%94%E2%80%94%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97/</id>
    <published>2020-11-17T09:06:33.000Z</published>
    <updated>2020-11-17T09:10:51.939Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;基础构建模块&quot;&gt;&lt;a href=&quot;#基础构建模块&quot; class=&quot;headerlink&quot; title=&quot;基础构建模块&quot;&gt;&lt;/a&gt;基础构建模块&lt;/h2&gt;&lt;h3 id=&quot;同步容器类&quot;&gt;&lt;a href=&quot;#同步容器类&quot; class=&quot;headerlink&quot; title=&quot;同步容器类&quot;&gt;&lt;/a&gt;同步容器类&lt;/h3&gt;&lt;p&gt;同步容器类包括早期的Vector（基本弃用）和&lt;code&gt;Hashtable&lt;/code&gt;（&lt;strong&gt;ConcurrentHashMap&lt;/strong&gt;（一致性hashmap）他不香吗），这些类的创建基本就是由&lt;code&gt;Collections.synchronizedXxx&lt;/code&gt;等工厂方法创建的。&lt;/p&gt;
&lt;h3 id=&quot;迭代容器&quot;&gt;&lt;a href=&quot;#迭代容器&quot; class=&quot;headerlink&quot; title=&quot;迭代容器&quot;&gt;&lt;/a&gt;迭代容器&lt;/h3&gt;&lt;p&gt;现在的许多容器也没有消除&lt;strong&gt;复合操作&lt;/strong&gt;的问题，对容器进行直接迭代的标准方式都是使用Iterator。但是这不能避免在迭代的过程中，其他线程也会并发的修改容器，所以很多容器的解决方案就是发现迭代时被修改了就马上抛出&lt;code&gt;concurrentModificationException&lt;/code&gt;，但只能当做并发问题的预警警示器。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程笔记(3)——对象的组合</title>
    <link href="http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-3-%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/"/>
    <id>http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-3-%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%84%E5%90%88/</id>
    <published>2020-11-17T09:03:28.000Z</published>
    <updated>2020-11-17T09:05:37.991Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;对象的组合&quot;&gt;&lt;a href=&quot;#对象的组合&quot; class=&quot;headerlink&quot; title=&quot;对象的组合&quot;&gt;&lt;/a&gt;对象的组合&lt;/h2&gt;&lt;p&gt;实际生产环境，我们不希望对每次内存的访问进行分析以实现线程安全，鹅绒希望吧线程安全组件进行组合以成为更大规模的组件。&lt;/p&gt;
&lt;h3 id=&quot;设计线程安全的类&quot;&gt;&lt;a href=&quot;#设计线程安全的类&quot; class=&quot;headerlink&quot; title=&quot;设计线程安全的类&quot;&gt;&lt;/a&gt;设计线程安全的类&lt;/h3&gt;&lt;p&gt;基本要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找出构成对象的所有变量&lt;/li&gt;
&lt;li&gt;找出约束状态条件的不变性条件&lt;/li&gt;
&lt;li&gt;建立对象状态的并发访问管理策略&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程笔记(2)——对象的共享</title>
    <link href="http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-2-%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/"/>
    <id>http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-2-%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/</id>
    <published>2020-11-17T09:03:13.000Z</published>
    <updated>2020-11-17T09:03:49.165Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;对象的共享&quot;&gt;&lt;a href=&quot;#对象的共享&quot; class=&quot;headerlink&quot; title=&quot;对象的共享&quot;&gt;&lt;/a&gt;对象的共享&lt;/h2&gt;&lt;p&gt;同步还有一个重要的方面，内存可见性(Memory Visibility)，简而言之，我们需要对一个对象在进行修改时，其他线程不会对这个对象进行修改，而且在修改完成之后，其他线程也能看到这个对象状态的变化。&lt;/p&gt;
&lt;h3 id=&quot;可见性&quot;&gt;&lt;a href=&quot;#可见性&quot; class=&quot;headerlink&quot; title=&quot;可见性&quot;&gt;&lt;/a&gt;可见性&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;重排序&lt;/strong&gt;：在编译器和处理时与运行时，可能对操作进行顺序进行进行重排序，所以对内存操作的顺序无法正确判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非原子的64位操作&lt;/strong&gt;：在Java中，long与double类型，JVM允许把其拆分成2个32位的进行计算。如果对这个变量的读操作和写操作在不同的线程中进行，可能就读取到错误的数据。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程笔记(1)——线程安全性</title>
    <link href="http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <id>http://bilikings.top/2020/11/17/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0-1-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/</id>
    <published>2020-11-17T09:00:25.000Z</published>
    <updated>2020-11-17T09:01:58.075Z</updated>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;什么是线程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;线程也成为轻量级进程&lt;/li&gt;
&lt;li&gt;进程是操作系统资源分配的最小单位，线程是cpu调度的最小单位&lt;/li&gt;
&lt;li&gt;同一个进程中的线程是都将共享进程的内存地址空间，因此这些形成都可以访问相同的变量并在一个堆上分配对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;线程安全性&quot;&gt;&lt;a href=&quot;#线程安全性&quot; class=&quot;headerlink&quot; title=&quot;线程安全性&quot;&gt;&lt;/a&gt;线程安全性&lt;/h2&gt;&lt;p&gt;如果多个线程访问同一个可变的状态变量时，没有使用合适的同步，程序就出现错误，解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不在线程中共享这个状态变量&lt;/li&gt;
&lt;li&gt;把状态变量修改为不可变的变量&lt;/li&gt;
&lt;li&gt;在访问状态时候使用同步&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>创建型模式——单例模式</title>
    <link href="http://bilikings.top/2020/11/16/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://bilikings.top/2020/11/16/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-16T02:33:31.000Z</published>
    <updated>2020-11-16T03:02:13.030Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h3&gt;&lt;p&gt;   &lt;strong&gt;确保一个类只有一个实例&lt;/strong&gt;，而且自行实例化并向整个系统提供这个实例，该类只提供一个取得其对象的方法。&lt;/p&gt;
&lt;h4 id=&quot;饿汉式（静态常量）&quot;&gt;&lt;a href=&quot;#饿汉式（静态常量）&quot; class=&quot;headerlink&quot; title=&quot;饿汉式（静态常量）&quot;&gt;&lt;/a&gt;饿汉式（静态常量）&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;构造器私有化（防止new）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类的内部创建对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;向外暴露一个静态公共方法&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Single&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//1构造器私有化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Single&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//内部创建实例对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Single instance =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Single();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Single &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;优点：写法简单，类装载的时候实例化，避免了线程同步&lt;/li&gt;
&lt;li&gt;缺点：可能造成内存的浪费&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式设计原则</title>
    <link href="http://bilikings.top/2020/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>http://bilikings.top/2020/11/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
    <published>2020-11-16T02:32:54.000Z</published>
    <updated>2020-11-16T02:34:14.406Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;找出应用中的变化之处，独立出来，不要和不需要编号的代码混在一起&lt;/li&gt;
&lt;li&gt;面向接口编程而不是面向实现编程&lt;/li&gt;
&lt;li&gt;为了交互对象的松耦合设计&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaJUC(二)——Concurrent包</title>
    <link href="http://bilikings.top/2020/11/15/JavaJUC-%E4%BA%8C-%E2%80%94%E2%80%94Concurrent%E5%8C%85/"/>
    <id>http://bilikings.top/2020/11/15/JavaJUC-%E4%BA%8C-%E2%80%94%E2%80%94Concurrent%E5%8C%85/</id>
    <published>2020-11-15T09:05:31.000Z</published>
    <updated>2020-11-15T09:06:43.539Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;java-util-concurrent&quot;&gt;&lt;a href=&quot;#java-util-concurrent&quot; class=&quot;headerlink&quot; title=&quot;java.util.concurrent&quot;&gt;&lt;/a&gt;java.util.concurrent&lt;/h1&gt;&lt;p&gt;这是一个jdk1.5之后的一个有关多线程的包&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JavaJUC(一)——线程</title>
    <link href="http://bilikings.top/2020/11/15/JavaJUC-%E4%B8%80-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/"/>
    <id>http://bilikings.top/2020/11/15/JavaJUC-%E4%B8%80-%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-11-15T09:03:28.000Z</published>
    <updated>2020-11-15T09:05:05.265Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;p&gt;进程是系统资源分配的基本单位&lt;/p&gt;
&lt;p&gt;线程是cpu进行调度的基本单位&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>通过反射定义注解</title>
    <link href="http://bilikings.top/2020/11/15/%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
    <id>http://bilikings.top/2020/11/15/%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-11-15T03:11:52.000Z</published>
    <updated>2020-11-15T03:12:35.440Z</updated>
    
    
    <summary type="html">&lt;p&gt;本文则以输入校验的 &lt;code&gt;@Length&lt;/code&gt;注解为例，自己动手实现一遍，这个学会了，其他注解实现原理也是类似。&lt;/p&gt;
&lt;h2 id=&quot;第一步：首先定义注解：-Length&quot;&gt;&lt;a href=&quot;#第一步：首先定义注解：-Length&quot; class=&quot;headerlink&quot; title=&quot;第一步：首先定义注解：@Length&quot;&gt;&lt;/a&gt;第一步：首先定义注解：@Length&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target(&amp;#123;ElementType.FIELD&amp;#125;)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//元注解&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//元注解&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; Length&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 允许字符串长度的最小值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 允许字符串长度的最大值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;errorMsg&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// 自定义的错误提示信息&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>人工智能基础</title>
    <link href="http://bilikings.top/2020/11/14/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/"/>
    <id>http://bilikings.top/2020/11/14/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-14T08:38:49.000Z</published>
    <updated>2020-11-14T08:40:57.305Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;人工智能基础复习材料&quot;&gt;&lt;a href=&quot;#人工智能基础复习材料&quot; class=&quot;headerlink&quot; title=&quot;人工智能基础复习材料&quot;&gt;&lt;/a&gt;人工智能基础复习材料&lt;/h1&gt;&lt;h2 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h2&gt;&lt;h3 id=&quot;人工智能-Artificial-Intelligence-：&quot;&gt;&lt;a href=&quot;#人工智能-Artificial-Intelligence-：&quot; class=&quot;headerlink&quot; title=&quot;人工智能(Artificial Intelligence)：&quot;&gt;&lt;/a&gt;人工智能(Artificial Intelligence)：&lt;/h3&gt;&lt;p&gt; 人工智能是研究、开发用于模拟、延伸和扩展人智能的理论、方法、技术及应用系统的一门新技术科学。 人工智能领域的研究包括机器人、语言识别、图像识别、自然语言处理和专家系统等。智能的定义：智能是 个人从经验中学习、理性思考、记忆重要信息、以及应付日常生活需求的认知能力。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://bilikings.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式&#39;</title>
    <link href="http://bilikings.top/2020/11/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://bilikings.top/2020/11/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-11-13T15:35:50.000Z</published>
    <updated>2020-11-13T15:49:34.534Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;p&gt;实例：&lt;/p&gt;
&lt;p&gt;匹配用户输入为19xx&lt;/p&gt;
&lt;p&gt;正则:19\d\d&lt;/p&gt;
&lt;p&gt;Java字符串”19\\d\\d“&lt;/p&gt;
&lt;h2 id=&quot;匹配&quot;&gt;&lt;a href=&quot;#匹配&quot; class=&quot;headerlink&quot; title=&quot;匹配&quot;&gt;&lt;/a&gt;匹配&lt;/h2&gt;&lt;h3 id=&quot;精确匹配规则&quot;&gt;&lt;a href=&quot;#精确匹配规则&quot; class=&quot;headerlink&quot; title=&quot;精确匹配规则&quot;&gt;&lt;/a&gt;精确匹配规则&lt;/h3&gt;&lt;p&gt;\u匹配指定Unicode字符&lt;/p&gt;
&lt;p&gt;. 可以匹配任意一个字符&lt;/p&gt;
&lt;p&gt;例如a.c 匹配abc，afc ，a%c&lt;/p&gt;
&lt;p&gt;\d 匹配一个数字&lt;/p&gt;
&lt;p&gt;\w 匹配一个数字、字母或者下划线&lt;/p&gt;
&lt;p&gt;\s 匹配一个空白字符 A\sB 匹配A B&lt;/p&gt;
&lt;p&gt;\W匹配非数字、字母或者下划线&lt;/p&gt;
&lt;p&gt;\S匹配一个非空白字符&lt;/p&gt;</summary>
    
    
    
    
    <category term="正则" scheme="http://bilikings.top/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>螺旋矩阵</title>
    <link href="http://bilikings.top/2020/11/12/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <id>http://bilikings.top/2020/11/12/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</id>
    <published>2020-11-12T05:55:54.000Z</published>
    <updated>2020-11-12T05:56:56.337Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;螺旋矩阵&quot;&gt;&lt;a href=&quot;#螺旋矩阵&quot; class=&quot;headerlink&quot; title=&quot;螺旋矩阵&quot;&gt;&lt;/a&gt;螺旋矩阵&lt;/h3&gt;&lt;p&gt;一个 n&lt;em&gt;n&lt;/em&gt; 行 n&lt;em&gt;n&lt;/em&gt; 列的螺旋矩阵可由如下方法生成：&lt;/p&gt;
&lt;p&gt;从矩阵的左上角（第 11 行第 11 列）出发，初始时向右移动；如果前方是未曾经过的格子，则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入 1, 2, 3, … , n^21,2,3,…,&lt;em&gt;n&lt;/em&gt;2，便构成了一个螺旋矩阵。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下图是一个 &lt;strong&gt;n=4&lt;/strong&gt; 时的螺旋矩阵。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1     2     3     4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12    13    14     5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11    16    15     6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10     9     8     7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://bilikings.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存回收概述</title>
    <link href="http://bilikings.top/2020/11/11/JVM%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/"/>
    <id>http://bilikings.top/2020/11/11/JVM%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0/</id>
    <published>2020-11-11T12:17:16.000Z</published>
    <updated>2020-11-11T12:18:22.511Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Java引用的功能和意义&lt;/li&gt;
&lt;li&gt;Java引用与内存回收之间的关系&lt;/li&gt;
&lt;li&gt;Java对象在内存中的不同状态&lt;/li&gt;
&lt;li&gt;软引用的作用和使用软引用的注意点&lt;/li&gt;
&lt;li&gt;弱引用的作用和使用弱引用的注意点&lt;/li&gt;
&lt;li&gt;虚引用的作用和使用虚引用的注意点&lt;/li&gt;
&lt;li&gt;Java内存泄漏的原因&lt;/li&gt;
&lt;li&gt;Java内存泄漏和C++内存泄漏的差别&lt;/li&gt;
&lt;li&gt;Java垃圾回收机制的基本算法&lt;/li&gt;
&lt;li&gt;堆内存的分代回收&lt;/li&gt;
&lt;li&gt;Young代、Old代和Permanent代的各自存储的对象&lt;/li&gt;
&lt;li&gt;Young代、Old代和Permanent代的特定及适用的回收算法&lt;/li&gt;
&lt;li&gt;常见垃圾回收机制对堆内存的回收细节&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://bilikings.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Stream</title>
    <link href="http://bilikings.top/2020/11/11/Stream/"/>
    <id>http://bilikings.top/2020/11/11/Stream/</id>
    <published>2020-11-11T08:39:37.000Z</published>
    <updated>2020-11-11T08:42:22.009Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Stream&quot;&gt;&lt;a href=&quot;#Stream&quot; class=&quot;headerlink&quot; title=&quot;Stream&quot;&gt;&lt;/a&gt;Stream&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;流式API&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个&lt;code&gt;Stream&lt;/code&gt;不同于&lt;code&gt;java.io&lt;/code&gt;的&lt;code&gt;InputStream&lt;/code&gt;和&lt;code&gt;OutputStream&lt;/code&gt;，它代表的是任意Java对象的序列。两者对比如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;java.io&lt;/th&gt;
&lt;th&gt;java.util.steam&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;存储&lt;/td&gt;
&lt;td&gt;顺序读写的byte或者char&lt;/td&gt;
&lt;td&gt;顺序输出的任意Java对象实例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用途&lt;/td&gt;
&lt;td&gt;序列化文件或者网络&lt;/td&gt;
&lt;td&gt;内存计算/业务逻辑&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://bilikings.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Lambda</title>
    <link href="http://bilikings.top/2020/11/11/Lambda/"/>
    <id>http://bilikings.top/2020/11/11/Lambda/</id>
    <published>2020-11-11T08:39:20.000Z</published>
    <updated>2020-11-11T08:42:13.976Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;java中，经常遇到一大堆单方法接口，即一个接口只定义了一个方法&lt;ul&gt;
&lt;li&gt;Comparator（比较器）&lt;/li&gt;
&lt;li&gt;Runnable&lt;/li&gt;
&lt;li&gt;Callable&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String[] arr =&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Arrays.sort(arr,&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Comparator&amp;lt;String&amp;gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String s1,String s2 )&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s1.compareTo(s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样写，非常繁琐&lt;/p&gt;
&lt;p&gt;java8开始用Lambda了替换单方法接口：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arrays.sort(arr,(s1,s2)-&amp;gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s1.compare(s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Lambda表达式值需要写出方法定义，参数类型可以省略&lt;/p&gt;
&lt;p&gt;只有一行return代码可以写成&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Arrays.sort(arr,(s1,s2)-&amp;gt;s1.compare(s2));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="java" scheme="http://bilikings.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>转发与重定向</title>
    <link href="http://bilikings.top/2020/11/11/%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://bilikings.top/2020/11/11/%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2020-11-11T08:36:23.000Z</published>
    <updated>2020-11-11T08:37:17.935Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;转发与重定向&quot;&gt;&lt;a href=&quot;#转发与重定向&quot; class=&quot;headerlink&quot; title=&quot;转发与重定向&quot;&gt;&lt;/a&gt;转发与重定向&lt;/h1&gt;&lt;p&gt;</summary>
        
      
    
    
    
    
    <category term="web" scheme="http://bilikings.top/tags/web/"/>
    
  </entry>
  
</feed>
